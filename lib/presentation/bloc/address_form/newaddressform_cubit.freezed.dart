// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'newaddressform_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$NewAddressFormStateTearOff {
  const _$NewAddressFormStateTearOff();

  _NewAddressFormState call(
      {required AddressInput cityInput,
      required MobilePhoneNumberInput mobilePhoneNumberInput,
      required AddressInput zoneInput,
      required AddressInput streetInput,
      required AddressInput buildingInput,
      required AddressInput floorInput,
      required AddressInput apartmentInput,
      required AddressInput villaInput,
      required AddressType addressType,
      required SubmissionState<AddressFailure> submissionState}) {
    return _NewAddressFormState(
      cityInput: cityInput,
      mobilePhoneNumberInput: mobilePhoneNumberInput,
      zoneInput: zoneInput,
      streetInput: streetInput,
      buildingInput: buildingInput,
      floorInput: floorInput,
      apartmentInput: apartmentInput,
      villaInput: villaInput,
      addressType: addressType,
      submissionState: submissionState,
    );
  }
}

/// @nodoc
const $NewAddressFormState = _$NewAddressFormStateTearOff();

/// @nodoc
mixin _$NewAddressFormState {
  AddressInput get cityInput => throw _privateConstructorUsedError;
  MobilePhoneNumberInput get mobilePhoneNumberInput =>
      throw _privateConstructorUsedError;
  AddressInput get zoneInput => throw _privateConstructorUsedError;
  AddressInput get streetInput => throw _privateConstructorUsedError;
  AddressInput get buildingInput => throw _privateConstructorUsedError;
  AddressInput get floorInput => throw _privateConstructorUsedError;
  AddressInput get apartmentInput => throw _privateConstructorUsedError;
  AddressInput get villaInput => throw _privateConstructorUsedError;
  AddressType get addressType => throw _privateConstructorUsedError;
  SubmissionState<AddressFailure> get submissionState =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NewAddressFormStateCopyWith<NewAddressFormState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NewAddressFormStateCopyWith<$Res> {
  factory $NewAddressFormStateCopyWith(
          NewAddressFormState value, $Res Function(NewAddressFormState) then) =
      _$NewAddressFormStateCopyWithImpl<$Res>;
  $Res call(
      {AddressInput cityInput,
      MobilePhoneNumberInput mobilePhoneNumberInput,
      AddressInput zoneInput,
      AddressInput streetInput,
      AddressInput buildingInput,
      AddressInput floorInput,
      AddressInput apartmentInput,
      AddressInput villaInput,
      AddressType addressType,
      SubmissionState<AddressFailure> submissionState});

  $AddressTypeCopyWith<$Res> get addressType;
  $SubmissionStateCopyWith<AddressFailure, $Res> get submissionState;
}

/// @nodoc
class _$NewAddressFormStateCopyWithImpl<$Res>
    implements $NewAddressFormStateCopyWith<$Res> {
  _$NewAddressFormStateCopyWithImpl(this._value, this._then);

  final NewAddressFormState _value;
  // ignore: unused_field
  final $Res Function(NewAddressFormState) _then;

  @override
  $Res call({
    Object? cityInput = freezed,
    Object? mobilePhoneNumberInput = freezed,
    Object? zoneInput = freezed,
    Object? streetInput = freezed,
    Object? buildingInput = freezed,
    Object? floorInput = freezed,
    Object? apartmentInput = freezed,
    Object? villaInput = freezed,
    Object? addressType = freezed,
    Object? submissionState = freezed,
  }) {
    return _then(_value.copyWith(
      cityInput: cityInput == freezed
          ? _value.cityInput
          : cityInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      mobilePhoneNumberInput: mobilePhoneNumberInput == freezed
          ? _value.mobilePhoneNumberInput
          : mobilePhoneNumberInput // ignore: cast_nullable_to_non_nullable
              as MobilePhoneNumberInput,
      zoneInput: zoneInput == freezed
          ? _value.zoneInput
          : zoneInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      streetInput: streetInput == freezed
          ? _value.streetInput
          : streetInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      buildingInput: buildingInput == freezed
          ? _value.buildingInput
          : buildingInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      floorInput: floorInput == freezed
          ? _value.floorInput
          : floorInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      apartmentInput: apartmentInput == freezed
          ? _value.apartmentInput
          : apartmentInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      villaInput: villaInput == freezed
          ? _value.villaInput
          : villaInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      addressType: addressType == freezed
          ? _value.addressType
          : addressType // ignore: cast_nullable_to_non_nullable
              as AddressType,
      submissionState: submissionState == freezed
          ? _value.submissionState
          : submissionState // ignore: cast_nullable_to_non_nullable
              as SubmissionState<AddressFailure>,
    ));
  }

  @override
  $AddressTypeCopyWith<$Res> get addressType {
    return $AddressTypeCopyWith<$Res>(_value.addressType, (value) {
      return _then(_value.copyWith(addressType: value));
    });
  }

  @override
  $SubmissionStateCopyWith<AddressFailure, $Res> get submissionState {
    return $SubmissionStateCopyWith<AddressFailure, $Res>(
        _value.submissionState, (value) {
      return _then(_value.copyWith(submissionState: value));
    });
  }
}

/// @nodoc
abstract class _$NewAddressFormStateCopyWith<$Res>
    implements $NewAddressFormStateCopyWith<$Res> {
  factory _$NewAddressFormStateCopyWith(_NewAddressFormState value,
          $Res Function(_NewAddressFormState) then) =
      __$NewAddressFormStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {AddressInput cityInput,
      MobilePhoneNumberInput mobilePhoneNumberInput,
      AddressInput zoneInput,
      AddressInput streetInput,
      AddressInput buildingInput,
      AddressInput floorInput,
      AddressInput apartmentInput,
      AddressInput villaInput,
      AddressType addressType,
      SubmissionState<AddressFailure> submissionState});

  @override
  $AddressTypeCopyWith<$Res> get addressType;
  @override
  $SubmissionStateCopyWith<AddressFailure, $Res> get submissionState;
}

/// @nodoc
class __$NewAddressFormStateCopyWithImpl<$Res>
    extends _$NewAddressFormStateCopyWithImpl<$Res>
    implements _$NewAddressFormStateCopyWith<$Res> {
  __$NewAddressFormStateCopyWithImpl(
      _NewAddressFormState _value, $Res Function(_NewAddressFormState) _then)
      : super(_value, (v) => _then(v as _NewAddressFormState));

  @override
  _NewAddressFormState get _value => super._value as _NewAddressFormState;

  @override
  $Res call({
    Object? cityInput = freezed,
    Object? mobilePhoneNumberInput = freezed,
    Object? zoneInput = freezed,
    Object? streetInput = freezed,
    Object? buildingInput = freezed,
    Object? floorInput = freezed,
    Object? apartmentInput = freezed,
    Object? villaInput = freezed,
    Object? addressType = freezed,
    Object? submissionState = freezed,
  }) {
    return _then(_NewAddressFormState(
      cityInput: cityInput == freezed
          ? _value.cityInput
          : cityInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      mobilePhoneNumberInput: mobilePhoneNumberInput == freezed
          ? _value.mobilePhoneNumberInput
          : mobilePhoneNumberInput // ignore: cast_nullable_to_non_nullable
              as MobilePhoneNumberInput,
      zoneInput: zoneInput == freezed
          ? _value.zoneInput
          : zoneInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      streetInput: streetInput == freezed
          ? _value.streetInput
          : streetInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      buildingInput: buildingInput == freezed
          ? _value.buildingInput
          : buildingInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      floorInput: floorInput == freezed
          ? _value.floorInput
          : floorInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      apartmentInput: apartmentInput == freezed
          ? _value.apartmentInput
          : apartmentInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      villaInput: villaInput == freezed
          ? _value.villaInput
          : villaInput // ignore: cast_nullable_to_non_nullable
              as AddressInput,
      addressType: addressType == freezed
          ? _value.addressType
          : addressType // ignore: cast_nullable_to_non_nullable
              as AddressType,
      submissionState: submissionState == freezed
          ? _value.submissionState
          : submissionState // ignore: cast_nullable_to_non_nullable
              as SubmissionState<AddressFailure>,
    ));
  }
}

/// @nodoc

class _$_NewAddressFormState implements _NewAddressFormState {
  const _$_NewAddressFormState(
      {required this.cityInput,
      required this.mobilePhoneNumberInput,
      required this.zoneInput,
      required this.streetInput,
      required this.buildingInput,
      required this.floorInput,
      required this.apartmentInput,
      required this.villaInput,
      required this.addressType,
      required this.submissionState});

  @override
  final AddressInput cityInput;
  @override
  final MobilePhoneNumberInput mobilePhoneNumberInput;
  @override
  final AddressInput zoneInput;
  @override
  final AddressInput streetInput;
  @override
  final AddressInput buildingInput;
  @override
  final AddressInput floorInput;
  @override
  final AddressInput apartmentInput;
  @override
  final AddressInput villaInput;
  @override
  final AddressType addressType;
  @override
  final SubmissionState<AddressFailure> submissionState;

  @override
  String toString() {
    return 'NewAddressFormState(cityInput: $cityInput, mobilePhoneNumberInput: $mobilePhoneNumberInput, zoneInput: $zoneInput, streetInput: $streetInput, buildingInput: $buildingInput, floorInput: $floorInput, apartmentInput: $apartmentInput, villaInput: $villaInput, addressType: $addressType, submissionState: $submissionState)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _NewAddressFormState &&
            (identical(other.cityInput, cityInput) ||
                const DeepCollectionEquality()
                    .equals(other.cityInput, cityInput)) &&
            (identical(other.mobilePhoneNumberInput, mobilePhoneNumberInput) ||
                const DeepCollectionEquality().equals(
                    other.mobilePhoneNumberInput, mobilePhoneNumberInput)) &&
            (identical(other.zoneInput, zoneInput) ||
                const DeepCollectionEquality()
                    .equals(other.zoneInput, zoneInput)) &&
            (identical(other.streetInput, streetInput) ||
                const DeepCollectionEquality()
                    .equals(other.streetInput, streetInput)) &&
            (identical(other.buildingInput, buildingInput) ||
                const DeepCollectionEquality()
                    .equals(other.buildingInput, buildingInput)) &&
            (identical(other.floorInput, floorInput) ||
                const DeepCollectionEquality()
                    .equals(other.floorInput, floorInput)) &&
            (identical(other.apartmentInput, apartmentInput) ||
                const DeepCollectionEquality()
                    .equals(other.apartmentInput, apartmentInput)) &&
            (identical(other.villaInput, villaInput) ||
                const DeepCollectionEquality()
                    .equals(other.villaInput, villaInput)) &&
            (identical(other.addressType, addressType) ||
                const DeepCollectionEquality()
                    .equals(other.addressType, addressType)) &&
            (identical(other.submissionState, submissionState) ||
                const DeepCollectionEquality()
                    .equals(other.submissionState, submissionState)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(cityInput) ^
      const DeepCollectionEquality().hash(mobilePhoneNumberInput) ^
      const DeepCollectionEquality().hash(zoneInput) ^
      const DeepCollectionEquality().hash(streetInput) ^
      const DeepCollectionEquality().hash(buildingInput) ^
      const DeepCollectionEquality().hash(floorInput) ^
      const DeepCollectionEquality().hash(apartmentInput) ^
      const DeepCollectionEquality().hash(villaInput) ^
      const DeepCollectionEquality().hash(addressType) ^
      const DeepCollectionEquality().hash(submissionState);

  @JsonKey(ignore: true)
  @override
  _$NewAddressFormStateCopyWith<_NewAddressFormState> get copyWith =>
      __$NewAddressFormStateCopyWithImpl<_NewAddressFormState>(
          this, _$identity);
}

abstract class _NewAddressFormState implements NewAddressFormState {
  const factory _NewAddressFormState(
          {required AddressInput cityInput,
          required MobilePhoneNumberInput mobilePhoneNumberInput,
          required AddressInput zoneInput,
          required AddressInput streetInput,
          required AddressInput buildingInput,
          required AddressInput floorInput,
          required AddressInput apartmentInput,
          required AddressInput villaInput,
          required AddressType addressType,
          required SubmissionState<AddressFailure> submissionState}) =
      _$_NewAddressFormState;

  @override
  AddressInput get cityInput => throw _privateConstructorUsedError;
  @override
  MobilePhoneNumberInput get mobilePhoneNumberInput =>
      throw _privateConstructorUsedError;
  @override
  AddressInput get zoneInput => throw _privateConstructorUsedError;
  @override
  AddressInput get streetInput => throw _privateConstructorUsedError;
  @override
  AddressInput get buildingInput => throw _privateConstructorUsedError;
  @override
  AddressInput get floorInput => throw _privateConstructorUsedError;
  @override
  AddressInput get apartmentInput => throw _privateConstructorUsedError;
  @override
  AddressInput get villaInput => throw _privateConstructorUsedError;
  @override
  AddressType get addressType => throw _privateConstructorUsedError;
  @override
  SubmissionState<AddressFailure> get submissionState =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$NewAddressFormStateCopyWith<_NewAddressFormState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$AddressTypeTearOff {
  const _$AddressTypeTearOff();

  _BuildingAddress building() {
    return const _BuildingAddress();
  }

  _VillaAddress villa() {
    return const _VillaAddress();
  }
}

/// @nodoc
const $AddressType = _$AddressTypeTearOff();

/// @nodoc
mixin _$AddressType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() building,
    required TResult Function() villa,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? building,
    TResult Function()? villa,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? building,
    TResult Function()? villa,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BuildingAddress value) building,
    required TResult Function(_VillaAddress value) villa,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BuildingAddress value)? building,
    TResult Function(_VillaAddress value)? villa,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BuildingAddress value)? building,
    TResult Function(_VillaAddress value)? villa,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressTypeCopyWith<$Res> {
  factory $AddressTypeCopyWith(
          AddressType value, $Res Function(AddressType) then) =
      _$AddressTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$AddressTypeCopyWithImpl<$Res> implements $AddressTypeCopyWith<$Res> {
  _$AddressTypeCopyWithImpl(this._value, this._then);

  final AddressType _value;
  // ignore: unused_field
  final $Res Function(AddressType) _then;
}

/// @nodoc
abstract class _$BuildingAddressCopyWith<$Res> {
  factory _$BuildingAddressCopyWith(
          _BuildingAddress value, $Res Function(_BuildingAddress) then) =
      __$BuildingAddressCopyWithImpl<$Res>;
}

/// @nodoc
class __$BuildingAddressCopyWithImpl<$Res>
    extends _$AddressTypeCopyWithImpl<$Res>
    implements _$BuildingAddressCopyWith<$Res> {
  __$BuildingAddressCopyWithImpl(
      _BuildingAddress _value, $Res Function(_BuildingAddress) _then)
      : super(_value, (v) => _then(v as _BuildingAddress));

  @override
  _BuildingAddress get _value => super._value as _BuildingAddress;
}

/// @nodoc

class _$_BuildingAddress implements _BuildingAddress {
  const _$_BuildingAddress();

  @override
  String toString() {
    return 'AddressType.building()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BuildingAddress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() building,
    required TResult Function() villa,
  }) {
    return building();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? building,
    TResult Function()? villa,
  }) {
    return building?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? building,
    TResult Function()? villa,
    required TResult orElse(),
  }) {
    if (building != null) {
      return building();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BuildingAddress value) building,
    required TResult Function(_VillaAddress value) villa,
  }) {
    return building(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BuildingAddress value)? building,
    TResult Function(_VillaAddress value)? villa,
  }) {
    return building?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BuildingAddress value)? building,
    TResult Function(_VillaAddress value)? villa,
    required TResult orElse(),
  }) {
    if (building != null) {
      return building(this);
    }
    return orElse();
  }
}

abstract class _BuildingAddress implements AddressType {
  const factory _BuildingAddress() = _$_BuildingAddress;
}

/// @nodoc
abstract class _$VillaAddressCopyWith<$Res> {
  factory _$VillaAddressCopyWith(
          _VillaAddress value, $Res Function(_VillaAddress) then) =
      __$VillaAddressCopyWithImpl<$Res>;
}

/// @nodoc
class __$VillaAddressCopyWithImpl<$Res> extends _$AddressTypeCopyWithImpl<$Res>
    implements _$VillaAddressCopyWith<$Res> {
  __$VillaAddressCopyWithImpl(
      _VillaAddress _value, $Res Function(_VillaAddress) _then)
      : super(_value, (v) => _then(v as _VillaAddress));

  @override
  _VillaAddress get _value => super._value as _VillaAddress;
}

/// @nodoc

class _$_VillaAddress implements _VillaAddress {
  const _$_VillaAddress();

  @override
  String toString() {
    return 'AddressType.villa()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _VillaAddress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() building,
    required TResult Function() villa,
  }) {
    return villa();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? building,
    TResult Function()? villa,
  }) {
    return villa?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? building,
    TResult Function()? villa,
    required TResult orElse(),
  }) {
    if (villa != null) {
      return villa();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_BuildingAddress value) building,
    required TResult Function(_VillaAddress value) villa,
  }) {
    return villa(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_BuildingAddress value)? building,
    TResult Function(_VillaAddress value)? villa,
  }) {
    return villa?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_BuildingAddress value)? building,
    TResult Function(_VillaAddress value)? villa,
    required TResult orElse(),
  }) {
    if (villa != null) {
      return villa(this);
    }
    return orElse();
  }
}

abstract class _VillaAddress implements AddressType {
  const factory _VillaAddress() = _$_VillaAddress;
}
